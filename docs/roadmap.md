# ロードマップ
## TODO LIST
- コンパイル処理を完成させる。
    - 現在2までは基礎が完成しているので、3, 4の部分を作る。
- とりあえずC言語への変換を実装する。それが終わったら各種GPUへ。
- グラフ内に別のグラフを埋め込むサブグラフ機能の実装。
- 計算グラフを表現するDSL（ドメイン特化言語）の設計。
- pythonから呼び出せるようにバインディングを作る    
- 自動微分の実装
- 配列をストレージに保存したり読み込んだりする機能
- ニューラルネットワークを作るための諸々
    - `torch.nn`, `torch.nn.functional`に相当する機能
    - 学習に必要な最適化手法(Adamとか)
- 画像や音声、動画、テキストなどを読み書きする機能
- 最適化処理のパターンを複数試して、最も早いものを採用する機能（ブラックボックス最適化）
    - ハイパーパラメータ探索に近い概念。
- 各分野の有名な論文の実装やHuggingFace上のモデルを推論
- 別途開発している自作言語の配列処理バックエンドとして組み込む

## コンパイルの流れ
コンパイルは以下のような流れで行われる。

1. 計算グラフの取得。  
ライブラリのAPIを使うか、他の言語のバインディングを使うなどして、計算グラフを取得します。

2. 計算グラフの検査と最適化  
不正な形状がないかをチェックしたり、受け取った計算グラフを`GraphOptimizer`で最適化します。  
たとえば、使用されていないノードを削除したり、定数項をあらかじめ計算したりなど。

3. 中間形式への変換  
トポロジカルソートアルゴリズムを用いて、ノードを計算する順番を計算します。
配列データを複製する処理があるかどうかをここで計算しておきます。確保するメモリ領域についてもここで計算します。
メモリ確保を動的に行う必要はないので、グラフの実行の最初に必要な領域を確保して、終わったら解放という流れで良さそう。
並列に計算できる部分があればそこも並列化するべきかも。

4. コードをレンダリングする  
中間形式のグラフを目的の言語(C, CUDA C++やMetalなど)に変換します。
変換した後はそれぞれのコンパイラを呼び出して、FFIなどを通じて関数を呼び出します。