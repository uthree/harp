# コード生成について
harpでは、計算グラフを受け取ってGPU向けのカーネルやC言語での高速な実装などにコンパイルすることが目的です。  

## レンダラー

### ノードレンダラー
ノードレンダラーは、Nodeを受け取ってソースコードを生成します。

```rust

// あるオペレーターがレンダリングできることを表すトレイト。
trait RenderNode<Op>
where Op: Operator // レンダラーによって利用可能な演算子が異なるため、ジェネリックトレイトを使って型システムでそれ表現する。
{
    fn render(&mut self, op: Op, src: Node) -> String; // とりあえずノードを再起的に探索することを想定してStringにしてるけど、もしかしたらもっと良い方法があるかも。
}

// たとえば、Metal(Apple版CUDAのようなもの)への変換はこのように実装する。
struct MetalRenderer {}
// オペレータごとに実装を追加していくイメージ。
impl RenderNode<AddOp> for MetalRenderer {
    ...
}

// FusedOpに関しては、レンダリング処理が実装されていない場合、フォールバックしてからレンダリングする。
```

### データ型レンダラー
あるデータ型がレンダリングできることを要求するトレイト。ノードとやることは同じなので詳細は略す。
```rust
trait DTypeRenderer<DType> {...}
```

## コンパイラー
生成されたコードをコンパイルする機能と、実際にそのコンパイラが利用可能であるかをチェックする機能を持ちます。
```rust

trait Compiler {
    fn is_available(&self) -> bool; //利用可能かチェックする。内部的には、コンパイラが使えるかどうかのシェルコマンドとかを叩く。
    fn compile(&self, code: String) -> impl Kernel // コンパイルされたカーネルを表すオブジェクトを返す。
}

// コンパイラを追加する場合はこう
struct CudaCompiler {}
impl Compiler for CudaCompiler {
    ...
}
```

## バックエンド
コードの解釈からコンパイル、最適化などを統括して行うためのインターフェース。
```rust

trait Backend {
    fn name(&self) -> String // 表示名を取得する。
    fn is_available(&self) -> bool // バックエンドが利用可能であるかチェックする。
}
trait Kernel {
    // GPU向けにコンパイルされたバイナリを呼び出すFFIのラッパー。
    // Fnトレイトなんかを組み込んで、関数と同じように扱えるようにすると便利そう。
} 
trait DeviceTensor { 
    // デバイス上にあるデータのポインタ。
    // ndarrayやVec<T>に変換する機能とか欲しいね。
    // デバイス間を移動する機能も必要になるはず。
    // dropされると解放
}

// たとえば、CUDAには複数のグラフィックカードを扱う機能があるため、以下のようにする。
struct Cuda<const device_id: usize = 0> {} // デバイス番号を型情報として持つ。
impl Backend for Cuda {
    ...
}
```

## 最適化
せっかく遅延評価でコード生成するなら、早いコードであるべきです。
しかし、最適化処理がどれくらい効果があるのかを計算で推測するのは困難であるため、バックエンドをブラックボックスとみなし、ベイズ最適化などをはじめとするブラックボックス最適化の手法を適応する方針を考えています。
