# 今後の課題

このドキュメントでは、現在の実装における制限事項と今後の課題を記録します。

## 複数出力のサポート

**優先度**: 中
**ステータス**: 未実装

### 概要

現在の実装では`Graph::output()`は単一出力のみをサポートしています。複数回呼び出すとpanicします。

### 背景

複数出力をサポートしようとした際に、以下の問題が発見されました：

1. **参照カウントの問題**
   - 出力ノード`x`が別の出力`y`の入力として使用される場合（例: `y = x + 1.0`）
   - `x`の参照カウントが2になる（出力としての参照 + `y`への入力としての参照）
   - `KernelMergeSuggester`は参照カウントが1のノードのみをマージ対象とするため、マージが妨げられる

2. **複数のKernelノードの統合**
   - 複数の独立した出力がある場合、それぞれに対応するKernelノードが生成される
   - これらを単一のProgramに統合する処理が不完全
   - 特に、出力間で共有されるノードの取り扱いが複雑

### 現在の回避策

- `Graph::output()`は最初の呼び出しのみを許可
- 2回目以降の呼び出しはpanicする
- ユーザーは単一の出力を持つグラフを設計する必要がある

### 解決方針（案）

1. **参照カウント方式の見直し**
   - 出力ノードとして登録されたノードを特別扱いする
   - 出力ノード間の依存関係を考慮したマージ戦略

2. **複数出力用のLoweringパス**
   - 複数出力を持つグラフ専用のlowering処理
   - 共有ノードの重複排除と適切なバッファ管理

3. **Program構造の拡張**
   - 複数のカーネル出力を持つmain関数の生成
   - 出力バッファ間の依存関係を考慮したバリア挿入

### 関連コード

- `src/graph/mod.rs`: `Graph::output()` メソッド
- `src/opt/graph/suggesters/kernel_merge.rs`: `KernelMergeSuggester`
- `src/backend/generic.rs`: `extract_program_from_graph()`

### 参考

この問題は2024年11月に発見されました。暫定的に単一出力制限を導入し、将来的な解決を予定しています。

---

## Buffer ノードの Sink 吸収

**優先度**: 低
**ステータス**: 延期

### 概要

最適化後、入力・出力の Buffer ノードがグラフ上に残る問題。理想的には、すべてのノードが ProgramRoot(Program) に吸収され、Buffer ノードはメタデータとしてのみ存在すべき。

### 現在の状態

- **出力 Buffer**: Sink.src から削除済み（`update_sink()` の修正により）
- **入力 Buffer**: まだ Sink.src に残存

### 実装の試み

`ProgramRootAbsorptionSuggester` で Buffer ノードをフィルタリングしようとしたが、以下の問題が発生：

1. **`outputs()` メソッドのマッピング崩壊**
   - `outputs()` は `sink.src[i]` が `outputs[i]` に対応すると仮定
   - Buffer フィルタリング後、この関係が崩壊し、間違った出力が返される

2. **カーネル引数生成の不一致**
   - カーネルパラメータは `Custom.src` の順序で生成される
   - main 関数の引数は `input_metas()` のソート順で生成される
   - 複数カーネルの場合、後のカーネルは前のカーネルの出力（中間結果）を入力として使用
   - 単純なバッファ名マッピングでは中間結果を追跡できない

3. **`KernelInfo` の追跡範囲**
   - `absorb_custom()` は1回に1つのカーネルのみ作成
   - 過去に作成されたカーネルの入力バッファ情報は失われる
   - フォールバック処理（パラメータ数からの推測）では順序が保証されない

### 技術的詳細

```
グラフ: a + b → temp → temp * c → result

吸収前:
  Sink.src = [Custom(add_then_mul), Buffer(a), Buffer(b), Buffer(c)]

Buffer フィルタリング後:
  Sink.src = [Custom(add_then_mul)]  # または []

問題:
  - outputs() が間違ったノードを返す
  - カーネル引数の対応が崩れる
```

### 解決方針（案）

1. **Sink 構造の再設計**
   - `Sink.src` を出力専用にし、入力情報は別フィールドで管理
   - `outputs()` を出力名→出力ノードの明示的マッピングに変更

2. **カーネル引数マッピングの改善**
   - 各カーネルの入力バッファ名を Program AST 内に保存
   - または、カーネルパラメータ名自体にバッファ名情報を含める

3. **中間バッファの明示的管理**
   - 中間結果バッファに一意の名前を付与
   - カーネル間のデータフローを追跡する仕組みを導入

### 関連コード

- `src/graph/mod.rs`: `Graph::outputs()`, `Graph::update_sink()`
- `src/opt/graph/suggesters/sink_absorption.rs`: `absorb_custom()`, `rebuild_sink_src()`
- `src/lowerer/mod.rs`: カーネル引数の生成

### 現在の回避策

Buffer ノードはグラフ上に残したまま、メタデータ（`input_metas`, `output_metas`）も併用する。
コード生成には影響なく、すべてのテストがパスしている。

### 参考

この問題は2024年11月に発見されました。Sink ベースアーキテクチャへの移行中に判明した設計上の課題です。
