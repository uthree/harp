# 動的カーネル引数リファクタリングの事後分析

## 1. 目的

現在のCバックエンドが生成するカーネルは、`void kernel_main(void** bufs, int* ints)` というハードコードされたシグネチャを持っており、特に`int* ints`の部分は柔軟性に欠け、ほとんど機能していなかった。

このリファクタリングの目的は、`UOp`グラフ内の`Const`ノードをカーネルへの動的なスカラー引数として渡せるようにし、ライブラリの柔軟性と表現力を向上させることだった。

## 2. 試みたアプローチ

1. **カーネルシグネチャの変更:**
    Cカーネルのシグネチャを `void kernel_main(void** bufs, void** scalar_args)` に変更し、任意の型のスカラー値をポインタの配列として渡せるように計画した。

2. **Rendererの責務変更:**
    * `CStyleRenderer`が`UOp`グラフを解析し、`Const`ノードを特定してスカラー引数として扱うようにする。
    * `render`メソッドが、生成したCコード (`String`) に加えて、カーネルに渡すべきスカラー値のリスト (`Vec<Number>`) を返すようにシグネチャを変更した。

3. **Backend/Kernelの連携変更:**
    * `ClangBackend`が`Renderer`からスカラー値のリストを受け取る。
    * `Kernel::exec`のシグネチャを変更し、バッファとスカラー値の両方を受け取るようにした。
    * `ClangKernel::exec`内で、受け取ったスカラー値を`void*`の配列に変換し、C関数に渡すロジックを実装した。

## 3. 発生した問題

一連の修正後、`pipeline_test`を実行すると、Clangのコンパイルエラーが一貫して発生し続けた。

* **エラー内容:** `use of undeclared identifier 'v_n'` (例: `v2`)
* **意味:** `lower`パスによって生成された一時変数が、Cコード内で宣言される前に使用されている。

## 4. 根本原因の分析

度重なる修正が失敗した原因は、`lower`パスが生成するAST（抽象構文木）の構造と、`Renderer`のAST解釈ロジックとの間の根本的な不一致にあった。

1. **`lower`の役割:** `lower`は、`Add`や`Load`などの式を含むUOpグラフを、`Store`文のリストで構成されるASTに変換する。この過程で、`v0`, `v1`, `v2`のような、元のグラフには存在しなかった新しい一時変数を導入する。

2. **Rendererの誤算:** 私が実装した`Renderer`の変数収集ロジック (`collect_args`) は、`lower`実行前のグラフ、あるいは`lower`が生成したASTの全体像を正しく把握できていなかった。そのため、一時変数`v_n`の存在を事前に知ることができず、Cコードの関数スコープの先頭でそれらを宣言することができなかった。

3. **スコープの問題:** その後の修正で、`Store`文を処理する際にその場で変数を宣言しようと試みた（`local_vars`セットを使用）。このアプローチの方向性は正しかったが、実装の詳細に誤りがあり、C言語のスコープルール（例: ループの内外）を正しく反映できなかったため、同じエラーが解消されなかった。

結論として、`lower`の役割と`Renderer`の役割の間の連携設計に根本的な欠陥があった。

## 5. 今後の推奨事項

この失敗から学び、次に同じ目標に挑戦する際は、以下のアプローチを推奨する。

1. **ASTの正確な理解:** `lower`がどのような入力に対してどのようなASTを出力するのかを、まず完全に理解し、ドキュメント化する。`dbg!`を使ったデバッグは、このために不可欠である。

2. **Rendererの責務を限定:** `Renderer`は、**`lower`が生成したASTを忠実にCコードに変換することだけに集中するべき**である。`lower`実行前のグラフ構造に関する知識を持つべきではない。

3. **状態管理の再設計:** `CStyleRenderContext`は、ASTを再帰的に走査するための状態のみを持つべきである。特に、現在のスコープでどの変数が宣言済みかを追跡する、より洗練された仕組みが必要となる。

4. **段階的な実装:** まずは最も単純なAST（例: `Store(Var, Const)`のみ）を正しくレンダリングできることを確認する。その後、`Block`、`Loop`、ネストした式、と段階的に対応範囲を広げ、各ステップでテストを行う。

このリファクタリングは依然として価値が高いが、成功させるためにはより慎重で段階的なアプローチが必要である。
