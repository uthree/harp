# 最適化処理について

## 最適化を行うステージ
harpは大きく分けて2つの最適化が可能な機会が存在する。

### 計算グラフ最適化
テンソル単位での計算グラフを最適化する。
例としては以下のようなもの。
 - 定数項を事前に計算
 - +0 や *1 などの計算結果に影響を及ぼさないノードの削除
 - 内部的な軸の入れ替え
 - 演算子の融合

### 構文木最適化
抽象構文木(AST)を最適化する。
例としては
 - 定数の事前計算
 - 不要ノードの削除
 - ループアンローリング
 - ループタイリング
 - ループ融合

## 最適化の種類
最適化の種類も以下の２種に分類される。

### 決定論的な最適化: Deterministic Optimization
不要な演算を削除・事前計算するなどの、最適化手法が比較的単純で、ほぼ全てのケースにおいて最適化を行ったほうが良いだろうと考えられるもの。
これらは、ブラックボックス最適化によって、グラフや構文木の置き換えをどこに適用するかなどを探索する必要性が**なく**、単純なものである。
そのため、この最適化は必ず実行される。

### ヒューリスティック最適化: Heuristic Optimization
置き換え規則によって計算結果が変わらないであることが保証されているが、置き換えるべきかどうかは実際に実行してみないと判明しないため、その判断を確立モデルやブラックボックス最適化によって行うもの。
これはその性質上、実際にコンパイルして計算を実行してみる必要があるため、時間がかかる。ゆえにオプション機能として実装する。
時間がかかる分より強力でアグレッシブな最適化が期待できる。
軸の入れ替えやループ展開などがこれに該当する。

## 結論
上記のことから、最適化は2x2=4種類に分類できる。

# 最適化アルゴリズムとその組み合わせを型で表現する
最適化アルゴリズムは手法や種類が多数あるため、それらに共通する部分をtraitで表現する必要がある。
また、それらのアルゴリズム同士を簡単に組み合わせられると便利である。

## 決定論的AST オプティマイザー
おそらくこれが一番単純。
ほとんどの場合、パターンマッチングによる単純な置き換えを使うはず。
```rust
trait DeterministicAstOptimizer {
    fn optimize(&AstNode) -> AstNode
}
```

## 決定論的グラフ オプティマイザー
```rust
trait DeterministicGraphOptimizer {
    fn optimize(&Graph) -> Graph
}