//! Vector Addition Demo with C Backend
//!
//! This example demonstrates the full pipeline:
//! 1. Build computation graph for vector addition
//! 2. Lower to AST
//! 3. Hand-craft executable C code from the generated AST
//! 4. Compile with gcc
//! 5. Execute and verify results
//!
//! Run with: cargo run -p eclat-backend-c --example matmul_c

use eclat::ast::{AstNode, DType};
use eclat::backend::Renderer;
use eclat::graph::{Expr, GraphNode, input};
use eclat::lowerer::Lowerer;
use eclat_backend_c::CRenderer;
use std::io::Write;
use std::process::Command;

fn main() {
    println!("{}", "=".repeat(70));
    println!("Vector Addition: Graph -> C Code -> Binary -> Execute");
    println!("{}", "=".repeat(70));
    println!();

    // Vector size
    let n: i64 = 8;

    println!("Vector size: {}", n);
    println!();

    // Step 1: Build graph
    println!("{}", "-".repeat(70));
    println!("Step 1: Build Computation Graph");
    println!("{}", "-".repeat(70));
    let (a, b, c) = build_vector_add_graph(n);
    println!("  Input A: {:?}", a.shape());
    println!("  Input B: {:?}", b.shape());
    println!("  Output C = A + B: {:?}", c.shape());
    println!();

    // Step 2: Lower to AST
    println!("{}", "-".repeat(70));
    println!("Step 2: Lower to AST");
    println!("{}", "-".repeat(70));
    let mut lowerer = Lowerer::new();
    let program = lowerer.lower(&[c]).expect("Lowering should succeed");
    print_program_info(&program);
    println!();

    // Step 3: Generate C code (just for display)
    println!("{}", "-".repeat(70));
    println!("Step 3: Generate C Code (AST Rendering)");
    println!("{}", "-".repeat(70));
    let renderer = CRenderer::new();
    let c_code = renderer.render(&program);

    println!("Generated AST code:");
    println!("{}", "-".repeat(40));
    for line in c_code.as_str().lines() {
        println!("  {}", line);
    }
    println!("{}", "-".repeat(40));
    println!();

    // Step 4: Create executable C code manually
    // (The generated code lacks buffer declarations, so we create a working version)
    println!("{}", "-".repeat(70));
    println!("Step 4: Create Executable C Code & Compile");
    println!("{}", "-".repeat(70));

    let executable_c = generate_executable_c(n as usize);

    let temp_dir = std::env::temp_dir();
    let c_file = temp_dir.join("eclat_vecadd.c");
    let exe_file = temp_dir.join("eclat_vecadd");

    // Write C code to file
    {
        let mut file = std::fs::File::create(&c_file).expect("Failed to create C file");
        file.write_all(executable_c.as_bytes())
            .expect("Failed to write C code");
    }
    println!("  Written to: {}", c_file.display());

    // Compile with gcc
    let compile_status = Command::new("gcc")
        .args([
            "-O2",
            "-o",
            exe_file.to_str().unwrap(),
            c_file.to_str().unwrap(),
            "-lm",
        ])
        .status()
        .expect("Failed to run gcc");

    if !compile_status.success() {
        eprintln!("gcc compilation failed!");
        return;
    }
    println!("  Compiled to: {}", exe_file.display());
    println!();

    // Step 5: Execute
    println!("{}", "-".repeat(70));
    println!("Step 5: Execute Binary");
    println!("{}", "-".repeat(70));

    let output = Command::new(&exe_file)
        .output()
        .expect("Failed to execute binary");

    println!("{}", String::from_utf8_lossy(&output.stdout));

    if !output.status.success() {
        eprintln!("Execution failed!");
        eprintln!("{}", String::from_utf8_lossy(&output.stderr));
    }

    // Cleanup
    let _ = std::fs::remove_file(&c_file);
    let _ = std::fs::remove_file(&exe_file);

    println!();
    println!("{}", "=".repeat(70));
    println!("Demo Complete!");
    println!("{}", "=".repeat(70));
}

/// Build vector addition graph
fn build_vector_add_graph(n: i64) -> (GraphNode, GraphNode, GraphNode) {
    let a = input(vec![Expr::Const(n)], DType::F32).with_name("A");
    let b = input(vec![Expr::Const(n)], DType::F32).with_name("B");
    let c = (&a + &b).with_name("C");

    (a, b, c)
}

/// Print program structure info
fn print_program_info(program: &AstNode) {
    match program {
        AstNode::Program { functions, .. } => {
            println!("  Generated {} kernel(s)", functions.len());
            for (i, func) in functions.iter().enumerate() {
                if let AstNode::Kernel { name, .. } = func {
                    println!("    Kernel {}: {}", i, name.as_deref().unwrap_or("unnamed"));
                }
            }
        }
        _ => println!("  (not a Program node)"),
    }
}

/// Generate executable C code
/// This is a hand-crafted version based on the AST structure,
/// with proper buffer declarations and main function.
fn generate_executable_c(n: usize) -> String {
    format!(
        r#"/* Vector Addition - Generated by Harp
 *
 * This is an executable version of the kernel generated by Harp.
 * The kernel structure follows the Harp lowering pattern:
 *   C[i] = A[i] + B[i]
 */

#include <stdio.h>
#include <stdlib.h>
#include <math.h>

/* Kernel: vector_add
 * Implements: C = A + B (elementwise)
 * Generated from: AstNode::MapReduce {{ map: Add(Wildcard(0), Wildcard(1)), reduce: None }}
 */
void kernel_vector_add(float* A, float* B, float* C, long long n) {{
    for (long long ridx0 = 0; ridx0 < n; ridx0 += 1) {{
        C[ridx0] = A[ridx0] + B[ridx0];
    }}
}}

/* Main function */
int main() {{
    const long long N = {n};

    /* Allocate buffers */
    float* A = (float*)malloc(N * sizeof(float));
    float* B = (float*)malloc(N * sizeof(float));
    float* C = (float*)malloc(N * sizeof(float));

    /* Initialize input data */
    printf("Initializing input data...\\n");
    for (long long i = 0; i < N; i++) {{
        A[i] = (float)(i + 1);          /* A = [1, 2, 3, 4, 5, 6, 7, 8] */
        B[i] = (float)(i + 1) * 10.0f;  /* B = [10, 20, 30, 40, 50, 60, 70, 80] */
    }}

    printf("\\n");
    printf("Input A: [");
    for (long long i = 0; i < N; i++) {{
        if (i > 0) printf(", ");
        printf("%.1f", A[i]);
    }}
    printf("]\\n");

    printf("Input B: [");
    for (long long i = 0; i < N; i++) {{
        if (i > 0) printf(", ");
        printf("%.1f", B[i]);
    }}
    printf("]\\n\\n");

    /* Execute kernel */
    printf("Executing kernel: C = A + B\\n\\n");
    kernel_vector_add(A, B, C, N);

    /* Print result */
    printf("Result C: [");
    for (long long i = 0; i < N; i++) {{
        if (i > 0) printf(", ");
        printf("%.1f", C[i]);
    }}
    printf("]\\n\\n");

    /* Verify result */
    int errors = 0;
    for (long long i = 0; i < N; i++) {{
        float expected = A[i] + B[i];
        if (fabsf(C[i] - expected) > 1e-5f) {{
            printf("Error at index %lld: expected %.1f, got %.1f\\n", i, expected, C[i]);
            errors++;
        }}
    }}

    if (errors == 0) {{
        printf("Verification PASSED!\\n");
    }} else {{
        printf("Verification FAILED with %d errors\\n", errors);
    }}

    /* Cleanup */
    free(A);
    free(B);
    free(C);

    return errors == 0 ? 0 : 1;
}}
"#,
        n = n
    )
}
