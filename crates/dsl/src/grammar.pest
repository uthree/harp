// Harp DSL Grammar

// Whitespace and comments
WHITESPACE = _{ " " | "\t" | "\r" | "\n" }
COMMENT = _{ "//" ~ (!"\n" ~ ANY)* }

// Module: collection of graph definitions
module = { SOI ~ graph_def* ~ EOI }

// Graph definition
// Supports two forms for return type:
// - Named outputs: graph foo(...) -> (a: f32[N], b: f32[M]) { ... }
// - Single unnamed output: graph foo(...) -> f32[N] { ... }
graph_def = {
    "graph" ~ generic_params? ~ ident ~ "(" ~ param_list? ~ ")" ~ "->" ~ return_type ~ block
}

// Return type can be:
// - A tuple of named parameters: (a: f32[N], b: f32[M])
// - A single tensor type: f32[N] (output name defaults to "output")
return_type = { "(" ~ param_list? ~ ")" | tensor_type }

// Generic parameters: <A, B, C>
generic_params = { "<" ~ ident ~ ("," ~ ident)* ~ ">" }

// Parameter list
param_list = { param ~ ("," ~ param)* }
param = { ident ~ ":" ~ tensor_type }

// Tensor type: f32[N, M] or f32[32, 64]
tensor_type = { dtype ~ "[" ~ shape_list ~ "]" }
dtype = { "f32" | "i32" | "bool" | "c64" }
shape_list = { shape_expr ~ ("," ~ shape_expr)* }

// Shape expressions (arithmetic on dimensions)
shape_expr = { shape_term ~ (shape_add_op ~ shape_term)* }
shape_term = { shape_factor ~ (shape_mul_op ~ shape_factor)* }
shape_factor = {
    "(" ~ shape_expr ~ ")"
    | integer
    | ident
}
shape_add_op = { "+" | "-" }
shape_mul_op = { "*" | "/" | "%" }

// Block of statements
block = { "{" ~ statement* ~ "}" }

// Statements
statement = {
    let_statement
    | assign_statement
    | return_statement
}

let_statement = { "let" ~ ident ~ "=" ~ expr }
assign_statement = { ident ~ "=" ~ expr }
return_statement = { "return" ~ ident }

// Expressions
expr = { comparison }

comparison = { additive ~ (comp_op ~ additive)* }
comp_op = { "==" | "!=" | "<=" | ">=" | "<" | ">" }

additive = { multiplicative ~ (add_op ~ multiplicative)* }
add_op = { "+" | "-" }

multiplicative = { unary ~ (mul_op ~ unary)* }
mul_op = { "*" | "/" | "%" }

unary = {
    unary_op ~ unary
    | postfix
}
unary_op = { "-" | "!" }

postfix = { primary ~ postfix_op* }
postfix_op = { method_call | index_access }

method_call = { "." ~ ident ~ "(" ~ arg_list? ~ ")" }
index_access = { "[" ~ arg_list ~ "]" }

primary = {
    "(" ~ expr ~ ")"
    | fused_expr
    | fused_reduce_expr
    | fused_cumulative_expr
    | function_call
    | float_literal
    | integer
    | ident
}

// Function call: matmul(a, b) or concat([a, b, c], 0)
function_call = { ident ~ "(" ~ arg_list? ~ ")" }

// Argument list
arg_list = { arg ~ ("," ~ arg)* }
arg = { named_arg | expr | array_literal }
named_arg = { ident ~ ":" ~ (expr | array_literal | ident) }

// Array literal: [a, b, c] or [1, 2, 3]
array_literal = { "[" ~ (array_elem ~ ("," ~ array_elem)*)? ~ "]" }
array_elem = { expr | tuple_literal }

// Tuple literal for padding: (1, 2)
tuple_literal = { "(" ~ expr ~ "," ~ expr ~ ")" }

// Fused operations
fused_expr = { "fused" ~ "(" ~ ident_list ~ ")" ~ fused_block }
fused_reduce_expr = { "fused_reduce" ~ "(" ~ ident_list ~ "," ~ fused_params ~ ")" ~ fused_block }
fused_cumulative_expr = { "fused_cumulative" ~ "(" ~ ident_list ~ "," ~ fused_params ~ ")" ~ fused_block }

ident_list = { ident ~ ("," ~ ident)* }
fused_params = { named_arg ~ ("," ~ named_arg)* }
fused_block = { "{" ~ expr ~ "}" }

// Literals
float_literal = @{
    "-"? ~ ASCII_DIGIT+ ~ "." ~ ASCII_DIGIT* ~ (("e" | "E") ~ ("+" | "-")? ~ ASCII_DIGIT+)?
    | "-"? ~ ASCII_DIGIT+ ~ ("e" | "E") ~ ("+" | "-")? ~ ASCII_DIGIT+
}
integer = @{ "-"? ~ ASCII_DIGIT+ }

// Identifier
ident = @{ (ASCII_ALPHA | "_") ~ (ASCII_ALPHANUMERIC | "_")* }
