// Eclat DSL Grammar
// PEG grammar for computation graph DSL

program = { SOI ~ "program" ~ "{" ~ graph_def* ~ "}" ~ EOI }

graph_def = {
    "graph" ~ shape_var_list? ~ ident ~ "(" ~ param_list? ~ ")" ~ "->" ~ type_spec ~ "{" ~ body ~ "}"
}

// Shape variable list for dynamic shapes: graph<batch, seq_len> name(...)
shape_var_list = { "<" ~ ident ~ ("," ~ ident)* ~ ">" }

param_list = { param ~ ("," ~ param)* }
param      = { ident ~ ":" ~ type_spec }

// Type specification: dtype[shape]
type_spec = { dtype ~ shape }
shape     = { "[" ~ dim ~ ("," ~ dim)* ~ "]" }
dim       = { integer | ident }
dtype     = { "f16" | "bf16" | "f32" | "f64" | "i32" | "i64" | "u32" | "u64" | "bool" }

// Graph body
body       = { statement* ~ return_stmt }
statement  = { let_stmt }
let_stmt   = { "let" ~ ident ~ "=" ~ expr ~ ";" }
return_stmt = { "return" ~ expr ~ ";" }

// Expressions (operator precedence)
expr           = { comparison }
comparison     = { additive ~ (comp_op ~ additive)* }
additive       = { multiplicative ~ (add_op ~ multiplicative)* }
multiplicative = { unary ~ (mul_op ~ unary)* }
unary          = { neg_op ~ unary | primary }
primary        = { func_call | literal | ident | "(" ~ expr ~ ")" }

func_call = { ident ~ "(" ~ (arg ~ ("," ~ arg)*)? ~ ")" }
arg       = { named_arg | shape_arg | expr_arg }
named_arg = { ident ~ "=" ~ (shape | expr) }
shape_arg = { "[" ~ dim ~ ("," ~ dim)* ~ "]" }
expr_arg  = { expr }

// Tokens
ident   = @{ ASCII_ALPHA ~ (ASCII_ALPHANUMERIC | "_")* }
integer = @{ ASCII_DIGIT+ }
float   = @{ ASCII_DIGIT+ ~ "." ~ ASCII_DIGIT* ~ (("e" | "E") ~ ("+" | "-")? ~ ASCII_DIGIT+)?
           | ASCII_DIGIT+ ~ ("e" | "E") ~ ("+" | "-")? ~ ASCII_DIGIT+ }
literal = { float | integer }

comp_op = { "<=" | ">=" | "==" | "!=" | "<" | ">" }
add_op  = { "+" | "-" }
mul_op  = { "*" | "/" }
neg_op  = { "-" }

COMMENT    = _{ "//" ~ (!NEWLINE ~ ANY)* ~ NEWLINE? }
WHITESPACE = _{ " " | "\t" | NEWLINE }
