// Multi-Output Subgraph Demo
// This example demonstrates tuple unpacking for subgraphs with multiple outputs.

// Split layer: returns both the linear output and the activated output
graph linear_with_preact(x: f32[B, I], w: f32[I, O], b: f32[O]) -> (preact: f32[B, O], act: f32[B, O]) {
    let xw = matmul(x, w)
    let b_exp = b.unsqueeze(0).expand([B, O])
    preact = xw + b_exp

    let zero = 0.0
    act = max(preact, zero)
}

// Residual connection: returns both sum and individual components
graph residual_add(x: f32[B, N], y: f32[B, N]) -> (sum: f32[B, N], original: f32[B, N]) {
    sum = x + y
    original = x
}

// Main graph using multi-output subgraphs with tuple unpacking
graph main(
    x: f32[B, D],
    w1: f32[D, H],
    b1: f32[H],
    w2: f32[H, D],
    b2: f32[D]
) -> (output: f32[B, D], preactivation: f32[B, D]) {
    // First layer with tuple unpacking
    let (pre1, act1) = linear_with_preact(x, w1, b1)

    // Second layer
    let (pre2, act2) = linear_with_preact(act1, w2, b2)

    // Return final output and first preactivation
    output = act2
    preactivation = pre2
}
